<style>
  #album-art-container {
    width: 20vh;
    object-fit: contain;
  }
  #songinfo-container {
    display: flex;
    flex-direction: row;
    align-items: cemter;
    gap: 1rem;
    background-color: var(--modal-bg);
    border: var(--generic-border);
    border-radius: var(--main-radius);
    width: 50vw;
    padding: calc(var(--main-radius) * 1.2);
    font-size: x-large;
  }
  #songinfo-info {
    gap: 1rem;
    display:flex;
    flex-direction: row;
    align-items: start;
    justify-content: start;
    border-radius: var(--main-radius);
    /* transform: translateX(-50%); */
    /* width: 50%; */
    margin-top: .5rem;
    height:max-content;
  }
  #album-art {
    border-radius: var(--main-radius);
    width: 20vh;
    border: var(--generic-border);
  }
  .lyric {
    font-size: x-large;
    transition: opacity 0.25s ease;
    opacity: 1;
  }
  .lyric.fade-out {
    opacity: 0;
  }
  .textbg-display {
    display: none !important;
  }

  #pbt {
    height: 5px;
    border-radius: var(--main-radius);
    outline: none;
    -webkit-appearance: none;
    --thumb-width: 0%;
    background: linear-gradient(to right, var(--indicator-green) var(--thumb-width), var(--slider-background) var(--thumb-width));
    position:absolute;
    bottom: calc(var(--main-radius) * 1.2);
    width: 50%;
  }
  #pbt::-webkit-slider-thumb, #pbt::-moz-range-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    /* border-radius: 50%; */
    cursor: pointer;
  }
</style>

<freedeck-dash-module>
  <div id="songinfo-container">
    <div id="album-art-container">
      <img id="album-art">
    </div>
    <span>
      <div id="songinfo-info">
        <div class="songtitle">Song</div>
        <div class="albumtitle">on Album</div>
        <div class="artists">Artists</div>
      </div>
      <p class="lyric">ooh</p>
      <input type="range" id="pbt">
    </span>
  </div>
</freedeck-dash-module>



    <script type="module">
      let isAuthorized = false;

      const title = document.querySelector(".songtitle")
      const album = document.querySelector(".albumtitle")
      const artistsT = document.querySelector(".artists")
      const lyricElement = document.querySelector(".lyric")

      let currentProgressMs = 0;
      let lastUpdateTimestamp = 0;
      let playbackIsPlaying = false;

      let lastDisplayedLyric = "";

      let lastLyric = {time:0,lyric:''}
      // Override getLyricAt to pick last lyric at or before current time
      function getLyricAt(timestampMs) {
        if (lyrics.not_exist || !lyrics.values || lyrics.values.length === 0) {
          lastLyric = { time: 0, lyric: "" };
          return lastLyric;
        }
        if (lyrics.type === "synced") {
          let current = lyrics.values[0];
          for (const lyricObject of lyrics.values) {
            if (lyricObject.time <= timestampMs) {
              current = lyricObject;
            } else {
              break;
            }
          }
          lastLyric = current;
        } else {
          lastLyric = { time: 0, lyric: lyrics.values || "" };
        }
        return lastLyric;
      }

      // Fade transition helper for lyrics
      function fadeLyricTo(newText) {
        if (lyricElement.classList.contains("fade-out")) return; // prevent overlap
        lyricElement.classList.add("fade-out");
        setTimeout(() => {
          lyricElement.innerText = newText;
          lyricElement.classList.remove("fade-out");
        }, 400);
      }

      // Update lyrics on animation frames
      function updateLyricsLoop() {
        const timestamp = getCurrentPlaybackProgressMs();
        const currentLyric = getLyricAt(timestamp);

        if (currentLyric.lyric !== lastDisplayedLyric) {
          fadeLyricTo(currentLyric.lyric);
          lastDisplayedLyric = currentLyric.lyric;
        }

        requestAnimationFrame(updateLyricsLoop);
      }

      // Function to get current playback progress interpolated
      function getCurrentPlaybackProgressMs() {
        if (playbackIsPlaying) {
          const now = performance.now();
          const elapsed = now - lastUpdateTimestamp;
          return currentProgressMs + elapsed;
        }
        return currentProgressMs;
      }
      const pbt = document.getElementById("pbt");

      universal.on("spotify_data", (data) =>{
        const {playbackState} = data;
        if(((playbackState.error?.status === 400 || playbackState.error?.status===401) || playbackState === "FIRST_TIME") && !isAuthorized) {
          isAuthorized = true;
        } else {
          isAuthorized = true;
        }
        if(!playbackState.item) return;

        playbackIsPlaying = playbackState.is_playing;
        currentProgressMs = playbackState.progress_ms || 0;
        lastUpdateTimestamp = performance.now();

        const albumName = playbackState.item?.album?.name;
        const artists = getArtistsNames(playbackState.item);
        const itemName = playbackState.item.name;
        const showing = `${artists} - ${itemName}`

        title.innerText = playbackState.item.name;
        if(albumName !== playbackState.item.name) {
          album.innerText = `${albumName}`;
          album.style.display = 'block';
        } else {
          album.style.display = 'none';
        }
        artistsT.innerText = artists
        if(playbackState.is_playing === false) {
          album.innerText = '(Paused)'
        }

        if(playbackState.shuffle_state === true) {
          makeAll("sp.shf", "green");
        } else {
          makeAll("sp.shf", "none");
        }

        const ctime = msToTimestamp(playbackState.progress_ms);
        const ttime = msToTimestamp(playbackState.item.duration_ms);
        // const currentLyric = lastLyric; // removed old direct usage
        getLyricAt(playbackState.progress_ms);

        pbt.min = 0;
        pbt.max = playbackState.item.duration_ms;
        pbt.value = currentProgressMs;
        const playbackPercent = (currentProgressMs / playbackState.item.duration_ms) * 100;
        pbt.style.setProperty('--thumb-width', `${playbackPercent}%`);


        const isPaused = playbackState.is_playing ? "" : " (Paused)";
        const tbgTitle = `${lastLyric.lyric}`;

        imgs = [];
        // lyric.innerText = lastLyric.lyric; // removed, replaced by animation frame loop

        const wantedCoverArt = playbackState.item.album.images[0].url;
        const imgElement = document.querySelector("#album-art") //TODO:ui
          if(imgElement.src !== wantedCoverArt) imgElement.src = wantedCoverArt;
          if(imgElement.style.width !== "100%") imgElement.style.width="100%";
          if(imgElement.style.height !== "100%") imgElement.style.height="100%";
        if(lyrics.type === 'none') {
          getLyricsFor(itemName, playbackState.item.artists[0].name, albumName, playbackState.item.duration_ms);
        } else {
          if(lyrics.current.name !== itemName) {
            getLyricsFor(itemName, playbackState.item.artists[0].name, albumName, playbackState.item.duration_ms);
          }
        }
      })

      const lyrics = {
        type: 'none',
        current: null,
        not_exist: true,
        values: null,
      };

      function getLyricsFor(name, artist, album, durationMs) {
        const url = new URL("https://lrclib.net/api/get");
        url.search = new URLSearchParams({
          track_name: name,
          artist_name: artist,
          album_name: album,
          duration: (durationMs/1000)
        }).toString()
        console.log("Fetching lyrics", url.toString())
        fetch(url).then(res=>res.json()).then((res) => {
          lyrics.not_exist = false;
          lyrics.current = {name, artist, album};
          if(res.syncedLyrics) {
            lyrics.type = "synced";
            lyrics.values = [];
            for(const line of res.syncedLyrics.split("\n")) {
              const timestamp = line.split("[")[1].split("]")[0];
              const ms = timestampToMs(timestamp);
              const actualText = line.split("] ")[1];
              const lyricObject = {
                time: ms,
                lyric: actualText
              }
              lyrics.values.push(lyricObject);
            }
          } else {
            lyrics.type = "generic";
            lyrics.values = res.plainLyrics || res || "";
          }
        }).catch((err) => {
          console.error('Error while grabbing lyrics', err);
        })
      }

      function makeAll(type, color) {
        for(const {element} of getAllOfType(type)) {
          if(color === "none") removeIndicatorFromButton(element)
          else setIndicatorToButton(element, color);
        }
      }

      function timestampToMs(timestamp) {
        const [minutes, seconds] = timestamp.split(':');
        const [secondsPart, milliseconds] = seconds.split('.');
        const totalMinutes = Number.parseInt(minutes);
        const totalSeconds = Number.parseInt(secondsPart);
        const totalMilliseconds = Number.parseInt(milliseconds);
        return (totalMinutes * 60 * 1000) + (totalSeconds * 1000) + totalMilliseconds;
      }

      let imgs = [];

      function msToTimestamp(ms) {
        const minutes = Math.floor(ms / 60000);
        const seconds = ((ms % 60000) / 1000).toFixed(0);
        return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
      }

      function getArtistsNames(playbackItem) {
        let output = "";
        const lastArtist = playbackItem.artists[playbackItem.artists.length-1];
        for(const artist of playbackItem.artists) {
          output += artist.name
          if(artist.name !== lastArtist.name) output += ", "
        }
        return output;
      }

      function setIndicatorToButton(btn, indicator) {
        if (!btn.querySelector('#sp_indi')) {
          let indicator = document.createElement('div');
          indicator.id = 'sp_indi';
          btn.appendChild(indicator);
        }
        const cl = btn.querySelector('#sp_indi').classList;
        cl.remove('indicator-red');
        cl.remove('indicator-green');
        cl.remove('indicator-yellow');
        cl.add('indicator-' + indicator);
      }

      function removeIndicatorFromButton(btn) {
        if (btn.querySelector('#sp_indi')) {
          btn.querySelector('#sp_indi').remove();
        }
      }

      function getAllOfType(type){
        let out = [];
        document.querySelectorAll('.button').forEach((btn) => {
          let inter = JSON.parse(btn.getAttribute('data-interaction'));
          if (inter != null && btn.id !== 'editor-btn') {
            if(inter.type == type) out.push({element:btn, interaction:inter})
          }
        });
        return out;
      }

      // Start lyric update loop
      updateLyricsLoop();

    </script>
